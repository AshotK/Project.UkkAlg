https://docs.google.com/document/d/1I1DKn_neMOrfMBzFNKnvPLjKUcVu8cK5RjzDKTxdg9s/edit

Алгоритм Укконена

Прежде чем познакомиться с этим алгоритмом, рассмотрим суффиксные деревья.

Суффиксное дерево

Суффиксное дерево - бор, содержащий все суффиксы некоторой строки (и только их). Позволяет выяснить, входит ли строка w в исходную строку t, за время O(|w|), где |w| - длина строки w.

Бор (префиксное дерево) - структура данных, позволяющая хранить ассоциативный массив, ключами которого являются строки.

Суффикс (подстрока) - это непустая связная часть строки.
Формальное определение 
	コ L = c0c1… cn-1 - строка длины n.
	 ∀ S = ci… cj , где 0  i  j n - 1, является подстрокой L длины j - i + 1
	если i = 0, то S называется префиксом L длины j + 1
	если j = n - 1, то S - суффикс L длины j - i + 1
Бонус (получение подстроки в С)):
Если line - исходная строка, begin - индекс первого символа подстроки, end - индекс последнего символа подстроки, то подстрока subline вычисляется следующим образом:

char* subline = (char*) malloc (end - begin + 2);
memcpy (subline, line + begin, end - begin + 1);
subline [end - begin + 1] = ‘\0’;

Основные определения и описание структуры

 - непустое конечное множество символов, называемое алфавитом. Последовательность символов (возможно, пустая) из алфавита обозначается буквами r, s и t. t-1представляет из себя перевернутую строку. Отдельные символы обозначаются буквами x, y и z. ε - пустая строка. Символами из алфавита являются буквы a, b, … Пока размер алфавита принимается постоянным. |t| обозначает длину строки t. ∑m - все строки длины m,
∑*= i=0∞∑iи ∑+= ∑*\ {ε}.
Префикс w строки t - строка такая, что wv = t для некоторой (возможно,пустой) строки v. Префикс называется собственным, если |v| 0;

Суффикс w строки t - строка такая, что vw = t для некоторой (возможно, пустой) строки v. Суффикс называется собственным, если |v| 0. 
Например, для строки “substring” подстрока “sub” является собственным префиксом, а подстрока “ring” - собственным суффиксом.

Подстрока w строки t называется правым ветвлением, если t может быть представлено как uwxv и u`wyv` для некоторых строк u, v, u` и v`, а также букв 
х   у. Левое ветвление определяется аналогично. 
Например, для “eabceeabcd” подстрока “abc” является правым ветвлением, так как в обоих ее вхождениях в t справа от нее стоят различные символы, зато та же подстрока не является левым ветвлением, потому что слева от нее в обоих вхождениях стоит одинаковый символ “e”.

∑+ - дерево Т - корневое дерево с ребрами, помеченными последовательностями из ∑+. Для каждого символа а из алфавита каждый узел в дереве Т имеет не более одного ребра, метка которого начинается с символа а. Ребро от t до s с меткой v мы будем обозначать t⟶vs.
Пусть k - узел ∑+ - дерева Т, тогда path(k) - строка, которая представляет собой конкатенацию (соединение нескольких строк в одну) всех меток ребер от корня до k. Мы назовем w местоположением w, для которого path(w) = w.

Так как каждая ветвь уникальна, если path(t) = w, мы можем обозначить узел t за w. Поддерево узла w обозначается Tw.

Слова, которые представлены в ∑+ -дереве Т, задаются множеством, которое обозначается words(T). Слово w входит в множество words(T) тогда и только тогда, когда существует строка v (возможно, пустая) такая, что wv - узел дерева Т.

Если строка w входит в words(T), w = uv, u - узел дерева Т, пару (u, v) будем называть ссылочной парой w по отношению к дереву Т. Если u - наидлиннейший префикс такой, что (u, v) - ссылочная пара, будем называть 
(u, v) канонической ссылочной парой. Тогда мы будем писать w = (u, v). Местоположение w = (u, v) называется явным, если |v| = 0, и неявным в противном случае.

∑+ -дерево Т, в котором каждое ребро помечено одиночным символом, называется атомарным (для него каждое местоположение является явным). 
∑+ -дерево Т, в котором каждый узел является либо корнем, либо листом или узлом ветвления, называется компактным.

Атомарное ∑+ -дерево также называют trie (луч). Атомарное и компактное 
∑+ -дерево однозначно определены словами, которые они содержат.

Суффиксное дерево для строки t - это ∑+ -дерево такое, что 
words(T) = {w| w - подслово t}. Для строки t атомарное суффиксное дерево обозначается ast(t), компактное суффиксное дерево обозначается cst(t).

Обратное префиксное дерево строки t - это суффиксное дерево для строки t-1.

Вложенный суффикс - суффикс, который входит в строку t где-нибудь еще. Наидлиннейший вложенный суффикс называется активным суффиксом строки t.

Свойства суффиксных деревьев

Лемма. 
Местоположение w явно в компактном суффиксном дереве тогда и только тогда, когда w является не вложенным суффиксом t или w - правое ветвление.

Доказательство. ⇒. Если w явно, то это может быть либо лист, либо вершина ветвления или корень (в этом случае w = ε и w — вложенный суффикс t).
Если w — лист, тогда также является и суффиксом t. Значит, это должен быть не вложенный суффикс, так как иначе он появился бы где-нибудь ещё в строке t: ヨ v — суффикс t такой, что w — префикс v. Этот узел не может быть листом.
Если w— узел ветвления, тогда должны существовать, по меньшей мере, два выходящих ребра из w с различными метками. Это означает, что существуют два различных суффикса u, v, что w — префикс u и w — префикс v, где v = wxs, u = wx's',
xx'}. Следовательно, w — правое ветвление.
. Если w является не вложенным суффиксом t, это должен быть лист. Если w — правое ветвление, то имеются два суффикса u и v, u = wxs, v = wx's'}, x x', тогда w является узлом ветвления. Лемма доказана.

Утверждение.
В ast(t) и cst(t $), где $ t, все суффиксные звенья являются атомарными.

Доказательство. Символ $ называется символом-стражем. Первая часть (для ast(t)) следует из определения, так как местоположения являются явными. Для доказательства второй (случай cst(t)) части мы должны показать, что для каждого узла aw w также является узлом cst(t). Если aw — узел cst(t), то является либо листом, либо узлом ветвления. Если является листом, тогда aw — не вложенный суффикс t. Благодаря символу-стражу, из леммы следует, что все суффиксы (включая корень, пустой суффикс) являются явными, так как только корень — вложенный суффикс. Поэтому w является листом или корнем. Если aw — узел ветвления, тогда aw — правое ветвление, как и w. Следовательно, местоположение w явно по лемме. Утверждение доказано.
Как следует из этого доказательства, символ-страж гарантирует существование листьев для всех суффиксов. С таким символом не может быть вложенных суффиксов, кроме пустого. Если мы опустим символ-страж, некоторые суффиксы могут стать вложенными, и их местоположения станут неявными.

Утверждение.
Компактное суффиксное дерево может быть представлено в виде, требующем O(n) памяти.

Доказательство. Суффиксное дерево содержит не более одного листа на каждый суффикс (в точности один с символом-стражем). Каждый внутренний узел должен быть узлом ветвления, следовательно, внутренний узел имеет по меньшей мере двух потомков. Каждое ветвление увеличивает число листьев по меньшей мере на единицу, поэтому мы имеем не более n внутренних узлов и не более n листьев.
Для представления строк, являющихся метками рёбер, мы используем индексацию в исходной строке, как описано выше. Каждый узел имеет не более одного предка и, таким образом, общее число ребер не превышает 2n.
Аналогично, каждый узел имеет не более одного суффиксного звена, тогда общее число суффиксных звеньев также ограничено числом 2n. Утверждение доказано.
Как пример суффиксного дерева с 2n-1 вершинами можно рассмотреть дерево для слова an$. Размер атомарного суффиксного дерева для строки t составляет O(n2).

Алгоритм Укконена -

алгоритм построения суффиксного дерева для заданной строки S за линейное время.

Алгоритм за O(n3)

Рассмотрим сначала наивный метод, который строит дерево за время O(n3), где n - длина исходной строки S. В дальнейшем данный алгоритм будет оптимизирован таким образом, что будет достигнута линейная скорость работы.

Определение.
Неявное суффиксное дерево строки S - это суффиксное дерево, построенное для строки S без добавления $.

Алгоритм последовательно строит неявные суффиксные деревья для всех префиксов исходного текста S = s1s2...sn. На i-ой фазе неявное суффиксное дерево ፒi-1 для префикса s[1...i-1] достраиваются до ፒi для префикса s[1...i]. Достраивание происходит следующим образом: для каждого суффикса подстроки s[1...i-1] необходимо спуститься от корня дерева до конца этого суффикса и дописать символ si.

Алгоритм состоит из n фаз. На каждой фазе происходит продление всех суффиксов текущего префикса строки, что требует O(n2) времени. Следовательно, общая асимптотика алгоритма составляет O(n3).

Псевдокод алгоритма за O(n3)

	for(int i = 1; i  n; i++) {
		for(int j = 1; j  n; j++) {
			treeExtend(s[j...i]) // добавление текущего суффикса работает  за линейное время

Замечание: на первый взгляд, более логичным подходом кажется добавление всех суффиксов строки в дерево по очереди, получив сразу алгоритм со временем работы O(n2) . Однако осуществить улучшение данного алгоритма до линейного времени работы будет намного сложней, хотя именно в этом и заключается суть алгоритма МакКрейта (это уже другой разговор).






Суффиксные ссылки

Определение.
Пусть х обозначает произвольную строку, где х - ее первый символ, а  - оставшаяся подстрока (возможно, пустая). Если для внутренней вершины v с путевой меткой х существует другая вершина s(v) с путевой меткой , то ссылка из v в s(v) называется суффиксной ссылкой.

Лемма (существование суффиксных ссылок)
Для любой внутренней вершины v суффиксного дерева существует суффиксная ссылка, ведущая в некоторую вершину u.

Доказательство. Рассмотрим внутреннюю вершину v с путевой меткой s[j…i]. Так как эта вершина внутренняя, её путевая метка ветвится справа в исходной строке. Тогда очевидно подстрока s[j+1…i] тоже ветвится справа в исходной строке, и ей соответствует некоторая внутренняя вершина uu. По определению суффиксная ссылка вершины vv ведёт в uu.

Использование суффиксных ссылок

Рассмотрим применение суффиксных ссылок. Пусть только что был продлен суффикс s[j...i-1] до суффикса s[j...i]. Теперь с помощью построенных ссылок можно найти конец суффикса s[j+1... i-1] в суффиксном дереве, чтобы продлить его до суффикса s[j+1...i]. Для этого надо пройти вверх по дереву до ближайшей внутренней вершины v, в которую ведет путь, помеченный s[j...r]. У вершины v точно есть суффиксная ссылка (о том, как строятся суффиксные ссылки, будет сказано позже, а пока можно просто поверить). Эта суффиксная ссылка ведет в вершину u, которой соответствует путь, помеченный подстрокой s[j+1...r]. Теперь от вершины u следует пройти вниз по дереву к концу суффикса s[j+1...i-1] и продлить его до суффикса s[j+1...i].

Можно заметить, что подстрока s[j+1...i-1] является суффиксом подстроки s[j...i-1]. Следовательно, после перехода по суффиксной ссылке в вершину, помеченную путевой меткой s[j+1...r], можно дойти до места, которому соответствует метка s[r+1...i-1], сравнивая не символы на ребрах, а лишь длину ребра по первому символу рассматриваемой части подстроки и длину самой этой подстроки. Таким образом можно спускаться вниз сразу на целое ребро.

Построение суффиксных ссылок

Легко увидеть, что в процессе построения суффиксного дерева уже построенные суффиксные ссылки никак не изменяются. Поэтому осталось сказать, как построить суффиксные ссылки для созданных вершин. Рассмотрим новую внутреннюю вершину v, которая была создана в результате продления суффикса s[j...i-1]. Вместо того, чтобы искать, куда должна указывать суффиксная ссылка вершины v, поднимаясь от корня дерева для этого, перейдем к продлению следующего суффикса s[j+1...i-1]. И в этот момент можно проставить суффиксную ссылку для вершины v. Она будет указывать либо на существующую вершину, если следующий суффикс закончился в ней, либо на новую созданную. То есть суффиксные ссылки будут обновляться с запаздыванием. Внимательно посмотрев на все три правила продления суффиксов, можно осознать, что для вершины v точно найдется на следующей фазе внутренняя вершина, в которую должна вести суффиксная ссылка.

Оценка числа переходов

Определение.
Глубиной вершины d(v) назовем число ребер на пути от корня до вершины v.

Лемма.
При переходе по суффиксной ссылке глубина уменьшается не более чем на 1.



Лемма (о числе переходов внутри фазы)
Число переходов внутри фазы номер i равно O(i).

Доказательство. Оценим количество переходов по рёбрам при поиске конца суффикса. Переход до ближайшей внутренней вершины уменьшает высоту на 1. Переход по суффиксной ссылке уменьшает высоту не более чем на 1 (по лемме, доказанной выше). А потом высота увеличивается, пока мы переходим по рёбрам вниз. Так как высота не может увеличиваться больше глубины дерева, а на каждой j-ой итерации мы уменьшаем высоту не более, чем на 2, то суммарно высота не может увеличиться больше чем на 2i. Итого, число переходов по рёбрам за одну фазу в сумме составляет O(i).

Асимптотика алгоритма с использованием суффиксных ссылок

Теперь в начале каждой фазы мы только один раз спускаемся от корня, а дальше используем переходы по суффиксным ссылкам. По доказанной лемме переходов внутри фазы будет O(i). А так как фаза состоит из i итераций, то амортизационно получаем, что на одной итерации будет выполнено O(1) действий. Следовательно, асимптотика алгоритма улучшилась до O(n2).

Линейный алгоритм 

Чтобы улучшить время работы данного алгоритма до O(n), нужно использовать линейное количество памяти,поэтому метка каждого ребра будет храниться как два числа - позиции ее самого левого и самого правого символов в исходном тексте.

Лемма (стал листом - листом и останешься) (1)
Если в какой-то момент работы алгоритма Укконена будет создан лист с меткой i (для суффикса, начинающегося в позиции i строки S), он останется листом во всех последовательных деревьях, созданных алгоритмом. 

Доказательство. Это верно потому, что у алгоритма нет механизма продолжения листового ребра дальше текущего листа. Если есть лист с суффиксом i, правило продолжения 1 будет применяться для продолжения i на всех последующих фазах.

Лемма (правило 3 заканчивает дело)
В любой фазе, если правило 3 применяется в продолжении суффикса, начинающегося в позиции j, оно же и будет применяться во всех дальнейших продолжениях (от j+1 по i) до конца фазы.

При использовании правила продолжения 3 путь, помеченный s[j…i−1] в текущем дереве, должен продолжаться символом ii, и точно так же продолжается путь, помеченный s[j+1…i−1], поэтому правило 3 применяется в продолжениях j+1, j+2,…,i.

Итоговая оценка времени работы

В течение работы алгоритма создается не более O(n) вершин по лемме о размере суффиксного дерева для строки. Все суффиксы, которые заканчиваются в листах, благодаря первой лемме (1) на каждой итерации мы увеличиваем на текущий символ по умолчанию за O(1). Текущая фаза алгоритма будет продолжаться, пока не будет использовано правило продления 3. Сначала неявно продлятся все листовые суффиксы, а потом по правилам 2(а) и 2(б) будет создано несколько новых внутренних вершин. Так как вершин не может быть создано больше, чем их есть, то амортизационно на каждой фазе будет создано O(1) вершин. Так как мы на каждой фазе начинаем добавление суффикса не с корня, а с индекса j*, на котором в прошлой фазе было применено правило 3, то используя немного модифицированный вариант леммы о числе переходов внутри фазы нетрудно показать, что суммарное число переходов по ребрам за все n фаз равно O(n).

Таким образом, при использовании всех приведеных эвристик алгоритм Укконена работает за O(n).

Минусы алгоритма Укконена

Несмотря на то, что данный алгоритм является одним из самых простых в понимании алгоритмов для построения суффиксных деревьев и использует online подход, у него есть серьезные недостатки, из-за которых его нечасто используют на практике:

Размер суффиксного дерева сильно превосходит входные данные, поэтому при очень больших данных алгоритм Укконена сталкивается с проблемой memory bottleneck (или же thrashing).
Для несложных задач, таких как поиск подстроки, проще и эффективней использовать другие алгоритмы (например поиск подстроки с помощью префикс-функции).
При внимательном просмотре видно, что на самом деле алгоритм работает за время O(n |Σ|), используя столько же памяти, так как для ответа на запрос о существовании перехода по текущему символу за O(1) необходимо хранить линейное количество информации от размера алфавита в каждой вершине. Поэтому, если алфавит очень большой, требуется чрезмерный объем памяти. Можно сэкономить на памяти, храня в каждой вершине только те символы, по которым из нее есть переходы, но тогда поиск перехода будет занимать O(log |Σ|) времени.
Константное время на одну итерацию - это амортизированная оценка, в худшем случае одна фаза может выполняться за O(n) времени. Например, алгоритм Дэни Бреслауера и Джузеппе Итальяно, хоть и строит дерево за O(n log log n), но на одну итерацию в худшем случае тратит O(log log n) времени.
На сегодняшний день существует кэш-эффективные алгоритмы, превосходящие алгоритм Укконена на современных процессорах.
Также алгоритм предполагает, что дерево полностью должно быть загружено в оперативную память. Если же требуется работать с большими размерами данных, то становится не так тривиально модифицировать алгоритм, чтобы он не хранил все дерево в ней.
